package cmd

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"

	"github.com/spf13/cobra"
	"github.com/uselagoon/build-deploy-tool/internal/helpers"
	"github.com/uselagoon/build-deploy-tool/internal/lagoon"
	routeTemplater "github.com/uselagoon/build-deploy-tool/internal/templating/routes"
)

var supportedAutogeneratedTypes = []string{
	// "kibana", //@TODO: don't even need this anymore?
	"node",
	"node-persistent",
	"nginx",
	"nginx-php",
	"nginx-php-persistent",
	"varnish",
	"varnish-persistent",
	"python-persistent",
	"python",
}

var autogenRouteGeneration = &cobra.Command{
	Use:     "autogenerated-ingress",
	Aliases: []string{"autogen-ingress", "autogen", "ai"},
	Short:   "Generate the autogenerated ingress templates for a Lagoon build",
	RunE: func(cmd *cobra.Command, args []string) error {
		return AutogeneratedIngressGeneration(true)
	},
}

func AutogeneratedIngressGeneration(debug bool) error {
	activeEnv := false
	standbyEnv := false

	lagoonEnvVars := []lagoon.EnvironmentVariable{}
	lagoonValues := lagoon.BuildValues{}
	lYAML := lagoon.YAML{}
	lCompose := lagoon.Compose{}
	lPolysite := make(map[string]interface{})
	err := collectBuildValues(debug, &activeEnv, &standbyEnv, &lagoonEnvVars, &lagoonValues, &lYAML, &lPolysite, &lCompose)
	if err != nil {
		return err
	}

	autogenEnabled := true
	// check if autogenerated routes are disabled
	if lYAML.Routes.Autogenerate.Enabled != nil {
		if *lYAML.Routes.Autogenerate.Enabled == false {
			autogenEnabled = false
		}
	}
	// check if pullrequests autogenerated routes are disabled
	if lagoonValues.BuildType == "pullrequest" && lYAML.Routes.Autogenerate.AllowPullRequests != nil {
		if *lYAML.Routes.Autogenerate.AllowPullRequests == false {
			autogenEnabled = false
		} else {
			autogenEnabled = true
		}
	}
	// check if this environment has autogenerated routes disabled
	if lYAML.Environments[lagoonValues.Branch].AutogenerateRoutes != nil {
		if *lYAML.Environments[lagoonValues.Branch].AutogenerateRoutes == false {
			autogenEnabled = false
		} else {
			autogenEnabled = true
		}
	}

	// get the router pattern
	lagoonRouterPattern, _ := lagoon.GetLagoonVariable("LAGOON_SYSTEM_ROUTER_PATTERN", []string{"internal_system"}, lagoonEnvVars)

	// generate autogenerated routes for the services
	autogenRoutes := &lagoon.RoutesV2{}
	for serviceName, service := range lCompose.Services {
		// get the service type
		serviceType := lagoon.CheckServiceLagoonLabel(service.Labels, "lagoon.type")

		// check if this service has autogenerated routes disabled
		serviceAutogenerated := lagoon.CheckServiceLagoonLabel(service.Labels, "lagoon.autogeneratedroute")
		if reflect.TypeOf(serviceAutogenerated).Kind() == reflect.String {
			vBool, err := strconv.ParseBool(serviceAutogenerated)
			if err == nil {
				autogenEnabled = vBool
			}
		}

		// if autogenerated routes are enabled, generate them :)
		if autogenEnabled {
			if helpers.Contains(supportedAutogeneratedTypes, serviceType) {
				domain, shortDomain := AutogeneratedDomainFromPattern(lagoonRouterPattern.Value, serviceName)
				lagoonValues.AutogeneratedRouteDomain = domain
				lagoonValues.ShortAutogeneratedRouteDomain = shortDomain

				// alternativeNames are `prefixes` for autogenerated routes
				alternativeNames := lYAML.Routes.Autogenerate.Prefixes
				altDomains := []string{}
				for _, altName := range alternativeNames {
					// add the prefix to the domain into a new slice of alternative domains
					altDomains = append(altDomains, fmt.Sprintf("%s.%s", altName, domain))
				}
				f := &lagoon.Fastly{}
				err := lagoon.GenerateFastlyConfiguration(f, fastlyCacheNoCahce, fastlyServiceID, domain, fastlyAPISecretPrefix, lagoonEnvVars)
				if err != nil {
					return err
				}
				autogenRoute := lagoon.RouteV2{
					Domain:  domain,
					Fastly:  *f,
					TLSAcme: helpers.BoolPtr(true),
					// overwrite the custom-ingress labels
					Labels: map[string]string{
						"lagoon.sh/autogenerated":    "true",
						"helm.sh/chart":              fmt.Sprintf("%s-%s", "autogenerated-ingress", "0.1.0"),
						"app.kubernetes.io/name":     "autogenerated-ingress",
						"app.kubernetes.io/instance": serviceName,
						"lagoon.sh/service":          serviceName,
						"lagoon.sh/service-type":     serviceType,
					},
					Service:          serviceName,
					IngressName:      serviceName,
					Migrate:          helpers.BoolPtr(false),
					Insecure:         helpers.StrPtr(lYAML.Routes.Autogenerate.Insecure), //use what is in lagoon.yml
					AlternativeNames: altDomains,
				}
				autogenRoutes.Routes = append(autogenRoutes.Routes, autogenRoute)
			}
		}
	}

	// generate the templates
	for _, route := range autogenRoutes.Routes {
		// autogenerated routes use the `servicename` as the name of the ingress resource, use `IngressName` in routev2 to handle this
		if debug {
			fmt.Println(fmt.Sprintf("Templating autogenerated ingress manifest for %s to %s", route.Domain, fmt.Sprintf("%s/%s.yaml", savedTemplates, route.IngressName)))
		}
		templateYAML := routeTemplater.GenerateIngressTemplate(route, lagoonValues, monitoringContact, monitoringStatusPageID, false)
		routeTemplater.WriteTemplateFile(fmt.Sprintf("%s/%s.yaml", savedTemplates, route.IngressName), templateYAML)
	}

	return nil
}

// AutogeneratedDomainFromPattern generates the domain name and the shortened domain name for an autogenerated ingress
func AutogeneratedDomainFromPattern(pattern, service string) (string, string) {
	domain := pattern
	shortDomain := pattern

	// fallback check for ${service} in the router pattern
	hasServicePattern := false
	if strings.Contains(pattern, "${service}") {
		hasServicePattern = true
	}

	// find and replace
	domain = strings.Replace(domain, "${service}", service, 1)
	domain = strings.Replace(domain, "${project}", projectName, 1)
	domain = strings.Replace(domain, "${environment}", environmentName, 1)
	// find and replace for the short domain
	shortDomain = strings.Replace(shortDomain, "${service}", service, 1)
	shortDomain = strings.Replace(shortDomain, "${project}", helpers.GetBase32EncodedLowercase(helpers.GetSha256Hash(projectName))[:8], 1)
	shortDomain = strings.Replace(shortDomain, "${environment}", helpers.GetBase32EncodedLowercase(helpers.GetSha256Hash(environmentName))[:8], 1)

	if !hasServicePattern {
		domain = fmt.Sprintf("%s.%s", service, domain)
		shortDomain = fmt.Sprintf("%s.%s", service, shortDomain)
	}

	domainParts := strings.Split(domain, ".")
	domainHash := helpers.GetSha256Hash(domain)
	finalDomain := ""
	for count, part := range domainParts {
		domainPart := part
		if len(part) > 63 {
			domainPart = fmt.Sprintf("%s-%s", part[:54], domainHash[:8])
		}
		if count == (len(domainParts) - 1) {
			finalDomain = fmt.Sprintf("%s%s", finalDomain, domainPart)
		} else {
			finalDomain = fmt.Sprintf("%s%s.", finalDomain, domainPart)
		}
	}
	return finalDomain, shortDomain
}

func init() {
	templateCmd.AddCommand(autogenRouteGeneration)
	autogenRouteGeneration.Flags().StringVarP(&lagoonYml, "lagoon-yml", "l", ".lagoon.yml",
		"The .lagoon.yml file to read")
	autogenRouteGeneration.Flags().StringVarP(&projectName, "project-name", "p", "",
		"The project name")
	autogenRouteGeneration.Flags().StringVarP(&environmentName, "environment-name", "e", "",
		"The environment name to check")
	autogenRouteGeneration.Flags().StringVarP(&environmentType, "environment-type", "E", "",
		"The type of environment (development or production)")
	autogenRouteGeneration.Flags().StringVarP(&buildType, "build-type", "d", "",
		"The type of build (branch, pullrequest, promote)")
	autogenRouteGeneration.Flags().StringVarP(&branch, "branch", "b", "",
		"The name of the branch")
	autogenRouteGeneration.Flags().StringVarP(&prNumber, "pullrequest-number", "P", "",
		"The pullrequest number")
	autogenRouteGeneration.Flags().StringVarP(&prHeadBranch, "pullrequest-head-branch", "H", "",
		"The pullrequest head branch")
	autogenRouteGeneration.Flags().StringVarP(&prBaseBranch, "pullrequest-base-branch", "B", "",
		"The pullrequest base branch")
	autogenRouteGeneration.Flags().StringVarP(&lagoonVersion, "lagoon-version", "L", "",
		"The lagoon version")
	autogenRouteGeneration.Flags().StringVarP(&templateValues, "template-path", "t", "/kubectl-build-deploy/",
		"Path to the template on disk")
	autogenRouteGeneration.Flags().StringVarP(&savedTemplates, "saved-templates-path", "T", "/kubectl-build-deploy/lagoon/services-routes",
		"Path to where the resulting templates are saved")
	autogenRouteGeneration.Flags().StringVarP(&fastlyCacheNoCahce, "fastly-cache-no-cache-id", "F", "",
		"The fastly cache no cache service ID to use")
	autogenRouteGeneration.Flags().StringVarP(&fastlyServiceID, "fastly-service-id", "f", "",
		"The fastly service ID to use")
	autogenRouteGeneration.Flags().StringVarP(&fastlyAPISecretPrefix, "fastly-api-secret-prefix", "A", "fastly-api-",
		"The fastly secret prefix to use")
	autogenRouteGeneration.Flags().BoolVarP(&checkValuesFile, "check-values-file", "C", false,
		"If set, will check for the values file defined in `${template-path}/values.yaml`")
}
