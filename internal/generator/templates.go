package generator

import (
	"fmt"
	"os"
	"os/exec"
	"strconv"
	"strings"

	networkv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"sigs.k8s.io/yaml"
)

// ReadValuesFile .
func ReadValuesFile(file string) LagoonValues {
	rawYAML, err := os.ReadFile(file)
	if err != nil {
		panic(fmt.Errorf("couldn't read %v: %v", file, err))
	}
	lValues := &LagoonValues{}
	yaml.Unmarshal(rawYAML, lValues)
	return *lValues
}

// GenerateKubeTemplate generates the lagoon template to apply.
func GenerateKubeTemplate(route RouteV2, lValues LagoonValues,
	monitoringContact, monitoringStatusPageID string,
	monitoringEnabled bool) []byte {
	ingressName := route.Domain
	if len(ingressName) >= 53 {
		ingressName = fmt.Sprintf("%s-%s", strings.Split(ingressName, ".")[0], getMD5HashWithNewLine(ingressName)[:5])
	}
	ingress := &networkv1.Ingress{}
	ingress.TypeMeta = metav1.TypeMeta{
		Kind:       "Ingress",
		APIVersion: "networking.k8s.io/v1",
	}
	ingress.ObjectMeta.Name = ingressName
	ingress.ObjectMeta.Labels = map[string]string{
		"dioscuri.amazee.io/migrate":   route.Migrate,
		"lagoon.sh/autogenerated":      "false",
		"helm.sh/chart":                fmt.Sprintf("%s-%s", "custom-ingress", "0.1.0"),
		"app.kubernetes.io/name":       "custom-ingress",
		"app.kubernetes.io/instance":   route.Domain,
		"app.kubernetes.io/managed-by": "Helm",
		"lagoon.sh/service":            route.Domain,
		"lagoon.sh/service-type":       "custom-ingress",
		"lagoon.sh/project":            lValues.Project,
		"lagoon.sh/environment":        lValues.Environment,
		"lagoon.sh/environmentType":    lValues.EnvironmentType,
		"lagoon.sh/buildType":          lValues.BuildType,
	}
	additionalLabels := map[string]string{}
	additionalLabels["dioscuri.amazee.io/migrate"] = "false"
	if route.Migrate != "" {
		additionalLabels["dioscuri.amazee.io/migrate"] = route.Migrate
	}
	for key, value := range additionalLabels {
		ingress.ObjectMeta.Labels[key] = value
	}
	ingress.ObjectMeta.Annotations = map[string]string{
		"kubernetes.io/tls-acme":                    *route.TLSAcme,
		"fastly.amazee.io/watch":                    strconv.FormatBool(route.Fastly.Watch),
		"lagoon.sh/version":                         lValues.LagoonVersion,
		"uptimerobot.monitor.stakater.com/interval": "60", //this is hardcoded
	}
	additionalAnnotations := map[string]string{}
	additionalAnnotations["monitor.stakater.com/enabled"] = "false"
	if monitoringEnabled {
		additionalAnnotations["monitor.stakater.com/enabled"] = "true"
	}
	additionalAnnotations["uptimerobot.monitor.stakater.com/alert-contacts"] = "unconfigured"
	if monitoringContact != "" {
		additionalAnnotations["uptimerobot.monitor.stakater.com/alert-contacts"] = monitoringContact
	}
	if monitoringStatusPageID != "" {
		additionalAnnotations["uptimerobot.monitor.stakater.com/status-pages"] = monitoringStatusPageID
	}
	if route.MonitoringPath != "" {
		additionalAnnotations["monitor.stakater.com/overridePath"] = route.MonitoringPath
	}
	if route.Fastly.ServiceID != "" {
		additionalAnnotations["fastly.amazee.io/service-id"] = route.Fastly.ServiceID
	}
	if route.Fastly.APISecretName != "" {
		additionalAnnotations["fastly.amazee.io/api-secret-name"] = route.Fastly.APISecretName
	}
	if lValues.BuildType == "branch" {
		additionalAnnotations["lagoon.sh/branch"] = lValues.Branch
	} else if lValues.BuildType == "pullrequest" {
		additionalAnnotations["lagoon.sh/prNumber"] = lValues.PRNumber
		additionalAnnotations["lagoon.sh/prHeadBranch"] = lValues.PRHeadBranch
		additionalAnnotations["lagoon.sh/prBaseBranch"] = lValues.PRBaseBranch

	}
	if *route.Insecure == "Allow" {
		additionalAnnotations["nginx.ingress.kubernetes.io/ssl-redirect"] = "false"
		additionalAnnotations["ingress.kubernetes.io/ssl-redirect"] = "false"
	} else if *route.Insecure == "Redirect" || *route.Insecure == "None" {
		additionalAnnotations["nginx.ingress.kubernetes.io/ssl-redirect"] = "true"
		additionalAnnotations["ingress.kubernetes.io/ssl-redirect"] = "true"
	}
	if lValues.EnvironmentType == "development" {
		additionalAnnotations["nginx.ingress.kubernetes.io/server-snippet"] = "add_header X-Robots-Tag \"noindex, nofollow\";\n"
	}
	for key, value := range additionalAnnotations {
		ingress.ObjectMeta.Annotations[key] = value
	}
	for key, value := range route.Annotations {
		ingress.ObjectMeta.Annotations[key] = value
	}
	ingress.Spec.TLS = []networkv1.IngressTLS{
		{
			Hosts:      []string{route.Domain},
			SecretName: fmt.Sprintf("%s-tls", ingressName),
		},
	}
	pt := networkv1.PathTypePrefix
	ingress.Spec.Rules = []networkv1.IngressRule{
		{
			Host: route.Domain,
			IngressRuleValue: networkv1.IngressRuleValue{
				HTTP: &networkv1.HTTPIngressRuleValue{
					Paths: []networkv1.HTTPIngressPath{
						{
							Path:     "/",
							PathType: &pt,
							Backend: networkv1.IngressBackend{
								Service: &networkv1.IngressServiceBackend{
									Name: route.Service,
									Port: networkv1.ServiceBackendPort{
										Name: "http",
									},
								},
							},
						},
					},
				},
			},
		},
	}
	ingressBytes, _ := yaml.Marshal(ingress)
	separator := []byte("---\n")
	result := append(separator[:], ingressBytes[:]...)
	return result
}

// GenerateHelmTemplates generates the lagoon template to apply.
// Use `GenerateKubeTemplate` instead, it is much faster
func GenerateHelmTemplates(
	template, values, domainValues string,
	route RouteV2, monitoringContact, monitoringStatusPageID string,
	monitoringEnabled, activeStandby bool) ([]byte, error) {
	annotations := &Annotations{
		Annotations: route.Annotations,
	}
	annotationBytes, _ := yaml.Marshal(annotations)
	err := os.WriteFile(domainValues, annotationBytes, 0644)
	if err != nil {
		return []byte{}, err
	}
	ingressName := route.Domain
	if len(ingressName) >= 53 {
		ingressName = fmt.Sprintf("%s-%s", strings.Split(ingressName, ".")[0], getMD5HashWithNewLine(ingressName)[:5])
	}
	args := []string{"template", ingressName, template,
		"--set", fmt.Sprintf("host=%s", route.Domain),
		"--set", fmt.Sprintf("service=%s", route.Service),
		"--set", fmt.Sprintf("tls_acme=%s", *route.TLSAcme),
		"--set", fmt.Sprintf("insecure=%s", *route.Insecure),
		"--set", fmt.Sprintf("hsts=%s", *route.HSTS),
		"--set", fmt.Sprintf("routeMigrate=%s", route.Migrate),
		"--set", fmt.Sprintf("ingressmonitorcontroller.enabled=%s", strconv.FormatBool(monitoringEnabled)),
		"--set", fmt.Sprintf("ingressmonitorcontroller.path=%s", route.MonitoringPath),
		"--set", fmt.Sprintf("ingressmonitorcontroller.alertContacts=%s", monitoringContact),
		"--set", fmt.Sprintf("ingressmonitorcontroller.statuspageId=%s", monitoringStatusPageID),
		"--set", fmt.Sprintf("fastly.watch=%s", strconv.FormatBool(route.Fastly.Watch)),
		"-f", values, "-f", domainValues,
	}
	cmd := exec.Command("helm", args...)
	stdout, err := cmd.Output()
	if err != nil {
		return []byte{}, err
	}
	return stdout, nil
}

// WriteTemplateFile writes the template to a file.
func WriteTemplateFile(templateOutputFile string, data []byte) {
	err := os.WriteFile(templateOutputFile, data, 0644)
	if err != nil {
		fmt.Println(err)
		return
	}
}
