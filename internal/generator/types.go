package generator

import (
	"encoding/json"
	"reflect"
	"strconv"
)

// RoutesV2 is the new routes definition
type RoutesV2 struct {
	Routes []RouteV2 `json:"routes"`
}

// RouteV2 is the new route definition
type RouteV2 struct {
	Domain         string            `json:"domain"`
	Service        string            `json:"service"`
	TLSAcme        *string           `json:"tls-acme"`
	Migrate        string            `json:"migrate,omitempty"`
	Insecure       *string           `json:"insecure,omitempty"`
	HSTS           *string           `json:"hsts,omitempty"`
	MonitoringPath string            `json:"monitoring-path,omitempty"`
	Fastly         Fastly            `json:"fastly,omitempty"`
	Annotations    map[string]string `json:"annotations"`
}

// Ingress represents a Lagoon route.
type Ingress struct {
	TLSAcme        *string           `json:"tls-acme,omitempty"`
	Migrate        string            `json:"migrate,omitempty"`
	Insecure       *string           `json:"insecure,omitempty"`
	HSTS           *string           `json:"hsts,omitempty"`
	MonitoringPath string            `json:"monitoring-path,omitempty"`
	Fastly         Fastly            `json:"fastly,omitempty"`
	Annotations    map[string]string `json:"annotations,omitempty"`
}

// Annotations .
type Annotations struct {
	Annotations map[string]string `json:"annotations,omitempty"`
}

// Fastly represents the fastly configuration for a Lagoon route
type Fastly struct {
	ServiceID     string `json:"service-id,omitempty"`
	APISecretName string `json:"api-secret-name,omitempty"`
	Watch         bool   `json:"watch,omitempty"`
}

// LagoonRoute can be either a string or a map[string]Ingress, so we must
// implement a custom unmarshaller.
type LagoonRoute struct {
	Name      string
	Ingresses map[string]Ingress
}

// UnmarshalJSON implements json.Unmarshaler.
func (lr *LagoonRoute) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &lr.Name); err == nil {
		return nil
	}
	if err := json.Unmarshal(data, &lr.Ingresses); err != nil {
		// some things in .lagoon.yml can be defined as bool or string and lagoon builds don't care
		// but types are more strict, so this unmarshaler attempts to change between the two types
		// that can be bool or string
		tmpMap := map[string]interface{}{}
		json.Unmarshal(data, &tmpMap)
		for k := range tmpMap {
			if _, ok := tmpMap[k].(map[string]interface{})["tls-acme"]; ok {
				if reflect.TypeOf(tmpMap[k].(map[string]interface{})["tls-acme"]).Kind() == reflect.Bool {
					vBool := strconv.FormatBool(tmpMap[k].(map[string]interface{})["tls-acme"].(bool))
					tmpMap[k].(map[string]interface{})["tls-acme"] = vBool
				}
			}
			if _, ok := tmpMap[k].(map[string]interface{})["fastly"]; ok {
				if reflect.TypeOf(tmpMap[k].(map[string]interface{})["fastly"].(map[string]interface{})["watch"]).Kind() == reflect.String {
					vBool, err := strconv.ParseBool(tmpMap[k].(map[string]interface{})["fastly"].(map[string]interface{})["watch"].(string))
					if err == nil {
						tmpMap[k].(map[string]interface{})["fastly"].(map[string]interface{})["watch"] = vBool
					}
				}
			}
		}
		newData, _ := json.Marshal(tmpMap)
		return json.Unmarshal(newData, &lr.Ingresses)
	}
	return json.Unmarshal(data, &lr.Ingresses)
}

// Environment represents a Lagoon environment.
type Environment struct {
	Routes []map[string][]LagoonRoute `json:"routes"`
}

// ProductionRoutes represents an active/standby configuration.
type ProductionRoutes struct {
	Active  *Environment `json:"active"`
	Standby *Environment `json:"standby"`
}

// Lagoon represents the .lagoon.yml file.
type Lagoon struct {
	Environments     map[string]Environment `json:"environments"`
	ProductionRoutes *ProductionRoutes      `json:"production_routes"`
}

// Environments .
type Environments map[string]Environment

// LagoonEnvironmentVariable is used to define Lagoon environment variables.
type LagoonEnvironmentVariable struct {
	Name  string `json:"name"`
	Value string `json:"value"`
	Scope string `json:"scope"`
}

// LagoonValues is the values file data generated by the lagoon build
type LagoonValues struct {
	Project                         string   `yaml:"project"`
	Environment                     string   `yaml:"environment"`
	EnvironmentType                 string   `yaml:"environmentType"`
	Namespace                       string   `yaml:"namespace"`
	GitSha                          int      `yaml:"gitSha"`
	BuildType                       string   `yaml:"buildType"`
	RoutesAutogeneratePrefixes      []string `yaml:"routesAutogeneratePrefixes"`
	RoutesAutogenerateInsecure      string   `yaml:"routesAutogenerateInsecure"`
	RoutesAutogenerateEnabled       string   `yaml:"routesAutogenerateEnabled"`
	RoutesAutogeneratePrefixHyphens string   `yaml:"routesAutogeneratePrefixHyphens"`
	Kubernetes                      string   `yaml:"kubernetes"`
	LagoonVersion                   string   `yaml:"lagoonVersion"`
	PodSecurityContext              struct {
		FsGroup    int `yaml:"fsGroup"`
		RunAsGroup int `yaml:"runAsGroup"`
		RunAsUser  int `yaml:"runAsUser"`
	} `yaml:"podSecurityContext"`
	ImagePullSecrets []struct {
		Name string `yaml:"name"`
	} `yaml:"imagePullSecrets"`
	Branch       string `yaml:"branch"`
	PRNumber     string `yaml:"prNumber"`
	PRHeadBranch string `yaml:"prHeadBranch"`
	PRBaseBranch string `yaml:"prBaseBranch"`
	Fastly       struct {
		Watch bool `yaml:"watch"`
	} `yaml:"fastly"`
	Route               string `yaml:"route"`
	Routes              string `yaml:"routes"`
	AutogeneratedRoutes string `yaml:"autogeneratedRoutes"`
	ConfigMapSha        string `yaml:"configMapSha"`
}
