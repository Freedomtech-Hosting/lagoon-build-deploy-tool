package generator

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"

	composetypes "github.com/compose-spec/compose-go/types"
	"github.com/uselagoon/build-deploy-tool/internal/lagoon"
)

func generateServicesFromDockerCompose(
	lagoonValues *BuildValues,
	lYAML *lagoon.YAML,
	lagoonEnvVars []lagoon.EnvironmentVariable,
	ignoreNonStringKeyErrors, ignoreMissingEnvFiles, debug bool,
) error {
	composeVars := make(map[string]string)
	for _, envvar := range lagoonEnvVars {
		composeVars[envvar.Name] = envvar.Value
	}

	// create the services map
	lagoonValues.Services = make(map[string]ServiceValues)
	lagoonServiceTypes, _ := lagoon.GetLagoonVariable("LAGOON_SERVICE_TYPES", []string{"build"}, lagoonEnvVars)

	// unmarshal the docker-compose.yml file
	lCompose, err := lagoon.UnmarshaDockerComposeYAML(lYAML.DockerComposeYAML, ignoreNonStringKeyErrors, ignoreMissingEnvFiles, composeVars)
	if err != nil {
		return err
	}

	// convert docker-compose services to servicevalues
	for _, csValues := range lCompose.Services {
		cService, err := composeToServiceValues(lYAML, lagoonValues, lagoonServiceTypes, csValues.Name, csValues)
		if err != nil {
			return err
		}
		lagoonValues.Services[csValues.Name] = cService
	}
	return nil
}

func composeToServiceValues(lYAML *lagoon.YAML, lagoonValues *BuildValues, lagoonServiceTypes *lagoon.EnvironmentVariable, csName string, csValues composetypes.ServiceConfig) (ServiceValues, error) {
	lagoonType := lagoon.CheckServiceLagoonLabel(csValues.Labels, "lagoon.type")
	autogenEnabled := true
	autogenTLSAcmeEnabled := true
	// check if autogenerated routes are disabled
	if lYAML.Routes.Autogenerate.Enabled != nil {
		if *lYAML.Routes.Autogenerate.Enabled == false {
			autogenEnabled = false
		}
	}
	// check if pullrequests autogenerated routes are disabled
	if lagoonValues.BuildType == "pullrequest" && lYAML.Routes.Autogenerate.AllowPullRequests != nil {
		if *lYAML.Routes.Autogenerate.AllowPullRequests == false {
			autogenEnabled = false
		} else {
			autogenEnabled = true
		}
	}
	// check if this environment has autogenerated routes disabled
	if lYAML.Environments[lagoonValues.Branch].AutogenerateRoutes != nil {
		if *lYAML.Environments[lagoonValues.Branch].AutogenerateRoutes == false {
			autogenEnabled = false
		} else {
			autogenEnabled = true
		}
	}
	// check if autogenerated routes tls-acme disabled
	if lYAML.Routes.Autogenerate.TLSAcme != nil {
		if *lYAML.Routes.Autogenerate.TLSAcme == false {
			autogenTLSAcmeEnabled = false
		}
	}
	if lagoonType != "" {
		if value, ok := lYAML.Environments[lagoonValues.Environment].Types[csName]; ok {
			lagoonType = value
		}
		if lagoonServiceTypes != nil {
			serviceTypesSplit := strings.Split(lagoonServiceTypes.Value, ",")
			for _, sType := range serviceTypesSplit {
				sTypeSplit := strings.Split(sType, ":")
				if sTypeSplit[0] == csName {
					lagoonType = sTypeSplit[1]
				}
			}
		}
		// check if the service has a specific override
		serviceAutogenerated := lagoon.CheckServiceLagoonLabel(csValues.Labels, "lagoon.autogeneratedroute")
		if serviceAutogenerated != "" {
			if reflect.TypeOf(serviceAutogenerated).Kind() == reflect.String {
				vBool, err := strconv.ParseBool(serviceAutogenerated)
				if err == nil {
					autogenEnabled = vBool
				}
			}
		}
		// check if the service has a tls-acme specific override
		serviceAutogeneratedTLSAcme := lagoon.CheckServiceLagoonLabel(csValues.Labels, "lagoon.autogeneratedroute.tls-acme")
		if serviceAutogeneratedTLSAcme != "" {
			if reflect.TypeOf(serviceAutogeneratedTLSAcme).Kind() == reflect.String {
				vBool, err := strconv.ParseBool(serviceAutogeneratedTLSAcme)
				if err == nil {
					autogenTLSAcmeEnabled = vBool
				}
			}
		}
		lagoonOverrideName := lagoon.CheckServiceLagoonLabel(csValues.Labels, "lagoon.name")
		if lagoonOverrideName != "" {
			for _, service := range lagoonValues.Services {
				if service.OverrideName == lagoonOverrideName {
					autogenEnabled = false
				}
			}
		}
		cService := ServiceValues{
			Name:                       csName,
			OverrideName:               lagoonOverrideName,
			Type:                       lagoonType,
			AutogeneratedRoutesEnabled: autogenEnabled,
			AutogeneratedRoutesTLSAcme: autogenTLSAcmeEnabled,
		}
		return cService, nil
	}
	return ServiceValues{}, fmt.Errorf("Service %s has no `lagoon.type` label in the docker-compose.yml file", csName)
}
