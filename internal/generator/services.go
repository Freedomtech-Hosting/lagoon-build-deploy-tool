package generator

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"

	composetypes "github.com/compose-spec/compose-go/types"
	"github.com/uselagoon/build-deploy-tool/internal/helpers"
	"github.com/uselagoon/build-deploy-tool/internal/lagoon"
)

// this is a map that maps old service types to their new service types
var oldServiceMap = map[string]string{
	"mariadb-shared":        "mariadb-dbaas",
	"postgres-shared":       "postgres-dbaas",
	"mongo-shared":          "mongodb-dbaas",
	"python-ckandatapusher": "python",
}

// these are lagoon types that support autogenerated routes
var supportedAutogeneratedTypes = []string{
	// "kibana", //@TODO: don't even need this anymore?
	"node",
	"node-persistent",
	"nginx",
	"nginx-php",
	"nginx-php-persistent",
	"varnish",
	"varnish-persistent",
	"python-persistent",
	"python",
}

// generateServicesFromDockerCompose unmarshals the docker-compose file and processes the services using composeToServiceValues
func generateServicesFromDockerCompose(
	lagoonValues *BuildValues,
	lYAML *lagoon.YAML,
	lagoonEnvVars []lagoon.EnvironmentVariable,
	ignoreNonStringKeyErrors, ignoreMissingEnvFiles, debug bool,
) error {
	composeVars := make(map[string]string)
	for _, envvar := range lagoonEnvVars {
		composeVars[envvar.Name] = envvar.Value
	}

	// create the services map
	lagoonValues.Services = make(map[string]ServiceValues)
	lagoonServiceTypes, _ := lagoon.GetLagoonVariable("LAGOON_SERVICE_TYPES", nil, lagoonEnvVars)
	lagoonValues.ServiceTypeOverrides = lagoonServiceTypes
	lagoonDBaaSEnvironmentTypes, _ := lagoon.GetLagoonVariable("LAGOON_DBAAS_ENVIRONMENT_TYPES", nil, lagoonEnvVars)
	lagoonValues.DBaaSEnvironmentTypeOverrides = lagoonDBaaSEnvironmentTypes

	// unmarshal the docker-compose.yml file
	lCompose, err := lagoon.UnmarshaDockerComposeYAML(lYAML.DockerComposeYAML, ignoreNonStringKeyErrors, ignoreMissingEnvFiles, composeVars)
	if err != nil {
		return err
	}

	// convert docker-compose services to servicevalues
	for _, composeServiceValues := range lCompose.Services {
		cService, err := composeToServiceValues(lagoonValues, lYAML, composeServiceValues.Name, composeServiceValues, debug)
		if err != nil {
			return err
		}
		lagoonValues.Services[composeServiceValues.Name] = cService
	}
	return nil
}

// composeToServiceValues is the primary function used to pre-seed how templates are created
// it reads the docker-compose file and converts each service into a ServiceValues struct
// this is the "known state" of that service, and all subsequent steps to create templates will use this data unmodified
func composeToServiceValues(
	lagoonValues *BuildValues,
	lYAML *lagoon.YAML,
	composeService string,
	composeServiceValues composetypes.ServiceConfig,
	debug bool,
) (ServiceValues, error) {
	lagoonType := ""
	// if there are no labels, then this is probably not going to end up in Lagoon
	if composeServiceValues.Labels != nil {
		lagoonType = lagoon.CheckServiceLagoonLabel(composeServiceValues.Labels, "lagoon.type")
	}
	if lagoonType != "" {
		autogenEnabled := true
		autogenTLSAcmeEnabled := true
		// check if autogenerated routes are disabled
		if lYAML.Routes.Autogenerate.Enabled != nil {
			if *lYAML.Routes.Autogenerate.Enabled == false {
				autogenEnabled = false
			}
		}
		// check if pullrequests autogenerated routes are disabled
		if lagoonValues.BuildType == "pullrequest" && lYAML.Routes.Autogenerate.AllowPullRequests != nil {
			if *lYAML.Routes.Autogenerate.AllowPullRequests == false {
				autogenEnabled = false
			} else {
				autogenEnabled = true
			}
		}
		// check if this environment has autogenerated routes disabled
		if lYAML.Environments[lagoonValues.Branch].AutogenerateRoutes != nil {
			if *lYAML.Environments[lagoonValues.Branch].AutogenerateRoutes == false {
				autogenEnabled = false
			} else {
				autogenEnabled = true
			}
		}
		// check if autogenerated routes tls-acme disabled
		if lYAML.Routes.Autogenerate.TLSAcme != nil {
			if *lYAML.Routes.Autogenerate.TLSAcme == false {
				autogenTLSAcmeEnabled = false
			}
		}
		// check lagoon yaml for an override for this service
		if value, ok := lYAML.Environments[lagoonValues.Environment].Types[composeService]; ok {
			lagoonType = value
		}
		// check if the service has a specific override
		serviceAutogenerated := lagoon.CheckServiceLagoonLabel(composeServiceValues.Labels, "lagoon.autogeneratedroute")
		if serviceAutogenerated != "" {
			if reflect.TypeOf(serviceAutogenerated).Kind() == reflect.String {
				vBool, err := strconv.ParseBool(serviceAutogenerated)
				if err == nil {
					autogenEnabled = vBool
				}
			}
		}
		// check if the service has a tls-acme specific override
		serviceAutogeneratedTLSAcme := lagoon.CheckServiceLagoonLabel(composeServiceValues.Labels, "lagoon.autogeneratedroute.tls-acme")
		if serviceAutogeneratedTLSAcme != "" {
			if reflect.TypeOf(serviceAutogeneratedTLSAcme).Kind() == reflect.String {
				vBool, err := strconv.ParseBool(serviceAutogeneratedTLSAcme)
				if err == nil {
					autogenTLSAcmeEnabled = vBool
				}
			}
		}
		// check if the service has a deployment servicetype override
		serviceDeploymentServiceType := lagoon.CheckServiceLagoonLabel(composeServiceValues.Labels, "lagoon.deployment.servicetype")
		if serviceDeploymentServiceType == "" {
			serviceDeploymentServiceType = composeService
		}
		// if there is a `lagoon.name` label on this service, this should be used as an override name
		lagoonOverrideName := lagoon.CheckServiceLagoonLabel(composeServiceValues.Labels, "lagoon.name")
		if lagoonOverrideName != "" {
			// if there is an override name, check all other services already existing
			for _, service := range lagoonValues.Services {
				// if there is an existing service with this same override name, then disable autogenerated routes
				// for this service
				if service.OverrideName == lagoonOverrideName {
					autogenEnabled = false
				}
			}
		} else {
			lagoonOverrideName = composeService
		}

		// if there are overrides defined in the lagoon API `LAGOON_SERVICE_TYPES`
		// handle those here
		if lagoonValues.ServiceTypeOverrides != nil {
			serviceTypesSplit := strings.Split(lagoonValues.ServiceTypeOverrides.Value, ",")
			for _, sType := range serviceTypesSplit {
				sTypeSplit := strings.Split(sType, ":")
				if sTypeSplit[0] == lagoonOverrideName {
					lagoonType = sTypeSplit[1]
				}
			}
		}

		// if there are no overrides, and the type is none, then abort here, no need to proceed calculating the type
		if lagoonType == "none" {
			return ServiceValues{}, nil
		}

		// convert old service types to new service types from the old service map
		if val, ok := oldServiceMap[lagoonType]; ok {
			lagoonType = val
		}

		// handle dbaas checks here
		dbaasEnvironment := lagoonValues.EnvironmentType
		if lagoonType == "mariadb" || lagoonType == "postgres" || lagoonType == "mongodb" {
			err := helpers.CheckDBaaSHealth(lagoonValues.DBaaSOperatorEndpoint)
			if err != nil {
				if debug {
					fmt.Println(fmt.Sprintf("Unable to check the DBaaS endpoint %s, falling back to %s-single: %v", lagoonValues.DBaaSOperatorEndpoint, lagoonType, err))
				}
				// normally we would fall back to doing a cluster capability check, this is phased out in the build tool, it isn't reliable
				lagoonType = fmt.Sprintf("%s-single", lagoonType)
			} else {
				// if there is a `lagoon.name` label on this service, this should be used as an override name
				dbaasLabelOverride := lagoon.CheckServiceLagoonLabel(composeServiceValues.Labels, fmt.Sprintf("lagoon.%s-dbaas.environment", lagoonType))
				if dbaasLabelOverride != "" {
					dbaasEnvironment = dbaasLabelOverride
				}

				// @TODO: maybe phase this out?
				// if value, ok := lYAML.Environments[lagoonValues.Environment].Overrides[composeService][mariadb][mariadb-dbaas].Environment; ok {
				// this isn't documented in the lagoon.yml, and it looks like a failover from days past.
				// 	lagoonType = value
				// }

				// if there are overrides defined in the lagoon API `LAGOON_DBAAS_ENVIRONMENT_TYPES`
				// handle those here
				exists := getDBaasEnvironment(lagoonValues, &dbaasEnvironment, lagoonOverrideName, lagoonType, debug)
				if exists {
					lagoonType = fmt.Sprintf("%s-dbaas", lagoonType)
				} else {
					lagoonType = fmt.Sprintf("%s-single", lagoonType)
				}
			}
		}

		// check if this service is one that supports autogenerated routes
		if !helpers.Contains(supportedAutogeneratedTypes, lagoonType) {
			autogenEnabled = false
			autogenTLSAcmeEnabled = false
		}

		// create the service values
		cService := ServiceValues{
			Name:                       composeService,
			OverrideName:               lagoonOverrideName,
			Type:                       lagoonType,
			AutogeneratedRoutesEnabled: autogenEnabled,
			AutogeneratedRoutesTLSAcme: autogenTLSAcmeEnabled,
			DBaaSEnvironment:           dbaasEnvironment,
		}
		return cService, nil
	}
	// service is not destined for Lagoon, return null
	return ServiceValues{}, nil //fmt.Errorf("Service %s has no `lagoon.type` label in the docker-compose.yml file", composeService)
}

// getDBaasEnvironment will check the dbaas provider to see if an environment exists or not
func getDBaasEnvironment(lagoonValues *BuildValues, dbaasEnvironment *string, lagoonOverrideName, lagoonType string, debug bool) bool {
	if lagoonValues.DBaaSEnvironmentTypeOverrides != nil {
		dbaasEnvironmentTypeSplit := strings.Split(lagoonValues.DBaaSEnvironmentTypeOverrides.Value, ",")
		for _, sType := range dbaasEnvironmentTypeSplit {
			sTypeSplit := strings.Split(sType, ":")
			if sTypeSplit[0] == lagoonOverrideName {
				*dbaasEnvironment = sTypeSplit[1]
			}
		}
	}
	exists, err := helpers.CheckDBaaSProvider(lagoonValues.DBaaSOperatorEndpoint, lagoonType, *dbaasEnvironment)
	if err != nil {
		if debug {
			fmt.Println(fmt.Sprintf("There was an error checking DBaaS endpoint %s, falling back to mariadb-single: %v", lagoonValues.DBaaSOperatorEndpoint, err))
		}
	}
	return exists
}
